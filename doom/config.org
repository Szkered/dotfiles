#+TITLE: Configuration
#+AUTHOR: Zekun Shi
#+PROPERTY: header-args :emacs-lisp :comments link
#+STARTUP: org-startup-folded: showall
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-
#+END_SRC

* Auth Info
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Zekun Shi"
      user-mail-address "derek.zekun.shi@gmail.com")

(load! "secret")
#+END_SRC

* Better Defaults
** shorten wait time
#+BEGIN_SRC emacs-lisp
(setq auto-revert-interval 0.5)
(setq avy-timeout-seconds 0.25)
#+END_SRC

** disable writegood
#+BEGIN_SRC emacs-lisp
(remove-hook 'org-mode-hook #'writegood-mode)
#+END_SRC

** don't use variable pitch font in treemacs
#+BEGIN_SRC emacs-lisp
(setq doom-themes-treemacs-enable-variable-pitch nil)
#+END_SRC

** before reloading the config, save all buffer
#+BEGIN_SRC emacs-lisp
(add-hook! 'doom-before-reload-hook
  (save-some-buffers t))
#+END_SRC

* Global Visual Settings
** themes

*** Use light / dark theme based on current time: circadian
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! circadian)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package! circadian
  :config
  (setq circadian-themes
   ;; '(("8:00" . doom-flatwhite)
   '(("8:00" . lambda-light-faded)
     ("18:30" . kanagawa-dragon)))
  (circadian-setup))
#+END_SRC

*** more themes
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! autothemer)
(package! doom-alabaster-theme :recipe (:host github :repo "agraul/doom-alabaster-theme"))
(package! ef-themes)
(package! lambda-themes :recipe (:host github :repo "lambda-emacs/lambda-themes"))
(package! mindre-theme)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package lambda-themes
  :custom
  (lambda-themes-set-italic-comments t)
  (lambda-themes-set-italic-keywords t)
  (lambda-themes-set-variable-pitch nil))
#+END_SRC

For ~doom-nano~ it requires ~def-doom-theme~
#+BEGIN_SRC emacs-lisp
(require 'doom-themes)
#+END_SRC

~doom-nano~ comes with a modeline
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! doom-nano-modeline
  :recipe (:host github
  :repo "ronisbr/doom-nano-modeline"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package! doom-nano-modeline
  :config
  (doom-nano-modeline-mode 1)
  (global-hide-mode-line-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook! '+doom-dashboard-functions (hide-mode-line-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! stimmung-themes)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package stimmung-themes :demand t)
#+END_SRC

** line number
No line number.
#+BEGIN_SRC emacs-lisp
(setq display-line-numbers-type nil)
#+END_SRC

** disable ~hl-line-mode~ in rainbow-mode
#+BEGIN_SRC emacs-lisp
(add-hook! 'rainbow-mode-hook
  (hl-line-mode (if rainbow-mode -1 +1)))
#+END_SRC

** laptop fonts
#+BEGIN_SRC emacs-lisp
(defun set-laptop-fonts ()
  (setq doom-font (font-spec :family "Iosevka Term SS04" :size 18 :dpi 116)
        doom-variable-pitch-font (font-spec :family "CMU Serif" :size 24 :dpi 116)
        doom-unicode-font (font-spec :family "Iosevka Nerd Font" :dpi 116)
        doom-big-font (font-spec :family "Iosevka Term SS04" :size 26 :dpi 116)))
#+END_SRC

mac
#+BEGIN_SRC emacs-lisp
(defun set-mac-fonts ()
  (setq doom-font (font-spec :family "Iosevka Term SS04" :size 18 :dpi 220)
        doom-variable-pitch-font (font-spec :family "CMU Serif" :size 20 :dpi 220)
        doom-unicode-font (font-spec :family "Iosevka Nerd Font" :dpi 220)
        doom-big-font (font-spec :family "Iosevka Term SS04" :size 26 :dpi 220)))
#+END_SRC

** monitor fonts
#+BEGIN_SRC emacs-lisp
(defun set-monitor-fonts ()
  (setq doom-font (font-spec :family "Iosevka Term SS04" :size 26 :dpi 163)
        doom-variable-pitch-font (font-spec :family "CMU Serif" :size 30 :dpi 163)
        doom-unicode-font (font-spec :family "Iosevka Nerd Font" :dpi 163)
        doom-big-font (font-spec :family "Iosevka Term SS04" :size 32 :dpi 163)))
#+END_SRC

** set font sizes based on dpi
We use the following shell command to get current dpi as ~x-display-pixel-width~ does not work in server mode.
#+BEGIN_SRC emacs-lisp
(defun get-current-dpi ()
  (string-to-number (shell-command-to-string "xrdb -query | grep dpi | awk '{print $2}'")))

(if (eq system-type 'darwin)
    (set-mac-fonts)
    (if (= (get-current-dpi) 116)
        (set-laptop-fonts)
        (set-monitor-fonts)))
#+END_SRC

* File manager: Dired / Ranger
** image preview
don't know why ranger's preview is not working
#+BEGIN_SRC emacs-lisp
(define-minor-mode dired-follow-mode
  "Diplay file at point in dired after a move."
  :lighter " dired-f"
  :global t
  (if dired-follow-mode
      (advice-add 'dired-next-line :after (lambda (arg) (dired-display-file)))
    (advice-remove 'dired-next-line (lambda (arg) (dired-display-file)))))
#+END_SRC

** yank buffer name
#+BEGIN_SRC emacs-lisp
(defun yank-buffer-file-name ()
  "Copy the current buffer's file name to the kill ring."
  (interactive)
  (if-let ((name (buffer-file-name)))
      (progn
        (kill-new name)
        (message "Buffer file name '%s' copied to clipboard" name))
    (message "Current buffer is not visiting a file")))

(map! "C-c n" 'yank-buffer-file-name)
#+END_SRC

** TODO load large file in chunks: vlf
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
;;(package! vlf)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;;(use-package! vlf
;;  :defer-incrementally vlf-tune vlf-base vlf-write vlf-search vlf-occur vlf-follow vlf-ediff vlf)
#+END_SRC

** keybinds
#+BEGIN_SRC emacs-lisp
(map!
  (:map dired-mode-map
    "f" 'dired-follow-mode
    "h" 'dired-up-directory
    "l" 'dired-display-file))
#+END_SRC

* Terminal: Vterm
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! multi-vterm)                  ;; for multiple vterms
(package! shell-pop)
#+END_SRC

** make auto-complete visible
#+BEGIN_SRC emacs-lisp
(setq shell-file-name "/bin/zsh")
(custom-set-faces! '(vterm-color-black :background "#839496"))
#+END_SRC
** more scroll back
#+BEGIN_SRC emacs-lisp
(setq vterm-max-scrollback 100000)
#+END_SRC

** send code
NOTE: need to disable ~read-only-mode~
#+BEGIN_SRC emacs-lisp
(defun sh-send-line-or-region (&optional step)
  (interactive ())
  (let ((proc (get-process "vterm"))
        pbuf min max command)
    (unless proc
      (let ((currbuff (current-buffer)))
        (shell)
        (switch-to-buffer currbuff)
        (setq proc (get-process "vterm"))))

    (setq pbuff (process-buffer proc))
    (if (use-region-p)
        (setq min (region-beginning)
              max (region-end))
      (setq min (point-at-bol)
            max (point-at-eol)))
    (setq command (concat (buffer-substring min max) "\n"))
    (with-current-buffer pbuff
      (goto-char (process-mark proc))
      (insert command)
      (move-marker (process-mark proc) (point)))
       ;;pop-to-buffer does not work with save-current-buffer -- bug?
    (process-send-string  proc command)
    (display-buffer (process-buffer proc) t)
    (when step
      (goto-char max)
      (next-line))))


(defun sh-send-line-or-region-and-step ()
  (interactive)
  (sh-send-line-or-region t))

(defun sh-switch-to-process-buffer ()
  (interactive)
  (pop-to-buffer (process-buffer (get-process "vterm")) t))
#+END_SRC

** keybinds
#+BEGIN_SRC emacs-lisp
(map!
 :leader
 :n "'" 'spacemacs/shell-pop-multi-vterm
 (:after multi-vterm
         (:map multi-vterm-mode-map
          :leader
          :n "mc" 'multi-vterm
          :n "mp" 'multi-vterm-prev
          :n "mn" 'multi-vterm-next)))
#+END_SRC

* tldr: an awesome cli reference: [[https://github.com/tldr-pages/tldr][github]]
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! tldr)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package! tldr
  :commands (tldr)
  :config
  (setq tldr-directory-path (concat doom-etc-dir "tldr/")))
#+END_SRC
* ChatGPT
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! gptel)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package! gptel
 :config
 (setq! gptel-api-key chatgpt-api-key))
#+END_SRC

* Coding
** Bazel
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! bazel)
#+END_SRC

** Python
*** auto-format
flake8+autoflake+yapf
#+BEGIN_SRC emacs-lisp
(set-formatter! 'yapf  "yapf " :modes '(python-mode))

(add-hook! 'before-save-hook
    (when (eq major-mode 'python-mode)
      (+format/buffer)))
#+END_SRC

*** debugger
#+BEGIN_SRC emacs-lisp
(defun python-toggle-breakpoint ()
  "Add an ipdb break point, highlight it."
  (interactive)
  (let ((trace (cond (t "breakpoint()")))
        (line (thing-at-point 'line)))
    (if (and line (string-match trace line))
        (kill-whole-line)
      (progn
        ;; (back-to-indentation)
        (insert trace)
        (insert "\n")
        (python-indent-line)))))
#+END_SRC

*** add extra syntax checker
#+BEGIN_SRC emacs-lisp
;; extra checkers after lsp
(defvar-local my/flycheck-local-cache nil)

(defun my/flycheck-checker-get (fn checker property)
  (or (alist-get property (alist-get checker my/flycheck-local-cache))
      (funcall fn checker property)))

(advice-add 'flycheck-checker-get :around 'my/flycheck-checker-get)

(add-hook 'lsp-managed-mode-hook
          (lambda ()
            (when (derived-mode-p 'python-mode)
              (setq my/flycheck-local-cache '((lsp . ((next-checkers . (python-pylint python-mypy python-flake8))))))
              (setq flycheck-pylintrc "~/.config/pylintrc"))))

#+END_SRC

*** ein
#+BEGIN_SRC emacs-lisp
(setq ein:output-area-inlined-images t)
(setq ein:use-auto-complete t)
(setq ein:use-smartrep t)
#+END_SRC

*** make repl popup nicer
#+BEGIN_SRC emacs-lisp
(set-popup-rule! "*Python*" :size 0.5 :side 'right :slot 1 :ttl nil :select nil :modeline nil :quit nil)
#+END_SRC

*** keybinds
#+begin_src emacs-lisp
(map!
 (:after python
  :map  python-mode-map
    :localleader
    "'"  #'+python/open-ipython-repl
    "a"  #'pyvenv-activate
    "D"  #'pyvenv-deactivate
    "sb" #'python-shell-send-buffer
    "sr" #'python-shell-send-region
    "SR" #'sh-send-line-or-region
    "db" #'python-toggle-breakpoint
    "if" #'python-fix-imports))
#+end_src

** C/C++
** Debugger Adapter (DAP)
*** keybinds
#+BEGIN_SRC emacs-lisp
(map!
 (:after dap-mode
   (:map dap-mode-map
    :leader
    "dd" 'dap-debug
    "de" 'dap-debug-edit-template
    "d." 'dap-hydra)))
#+END_SRC

** Copilot
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! copilot
  :recipe (:host github :repo "zerolfx/copilot.el" :files ("*.el" "dist")))
#+END_SRC

#+begin_src emacs-lisp
;; accept completion from copilot and fallback to company
(use-package! copilot
  :hook (prog-mode . copilot-mode)
  :bind (:map copilot-completion-map
              ("C-e" . 'copilot-accept-completion)
              ("M-f" . 'copilot-accept-completion-by-word)
              ))
#+end_src

* Org-mode
** file location
#+begin_src emacs-lisp
(setq org-directory "~/Dropbox/notes/")
(setq org-roam-directory "~/Dropbox/notes/roam")
(setq org-agenda-files (directory-files-recursively "~/Dropbox/notes/" "\\.org$"))

(defun filter-org-file (file)
  (equal (car (last (split-string file "\\."))) "org"))

(setq all-org-files
      (seq-filter 'filter-org-file (directory-files-recursively "~/Dropbox/notes/" ".*")))
#+end_src
** org-download
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! org-download)
#+END_SRC

** org-analyzer
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! org-analyzer)
#+END_SRC

** auto tangle
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! org-auto-tangle)
#+END_SRC

#+begin_src emacs-lisp
(use-package org-auto-tangle
  :defer t
  :hook (org-mode . org-auto-tangle-mode))
#+end_src

** TODO org-special-block-extra
http://alhassy.com/org-special-block-extras/

** roam-ui
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! org-roam-ui)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package! websocket
    :after org-roam)

(use-package! org-roam-ui
    :after org-roam ;; or :after org
;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
;;         a hookable mode anymore, you're advised to pick something yourself
;;         if you don't care about startup time, use
;;  :hook (after-init . org-roam-ui-mode)
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))
#+END_SRC
** visual settings

#+begin_src emacs-lisp
(setq org-ellipsis "‚Ä¶")
#+end_src

Mixed pitch is great. As is ~+org-pretty-mode~, let's use them.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook #'+org-pretty-mode)
#+end_src

Let's make headings a bit bigger
#+begin_src emacs-lisp
(custom-set-faces!
  '(outline-1 :weight extra-bold :height 1.25)
  '(outline-2 :weight bold :height 1.15)
  '(outline-3 :weight bold :height 1.12)
  '(outline-4 :weight semi-bold :height 1.09)
  '(outline-5 :weight semi-bold :height 1.06)
  '(outline-6 :weight semi-bold :height 1.03)
  '(outline-8 :weight semi-bold)
  '(outline-9 :weight semi-bold))
#+end_src

** extra nice visual: org-modern
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! org-modern)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook #'org-modern-mode)
(add-hook 'org-agenda-finalize-hook #'org-modern-agenda)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Minimal UI
(after! org-modern
  (setq
   ;; Edit settings
   org-auto-align-tags nil
   org-tags-column 0
   org-catch-invisible-edits 'show-and-error
   org-special-ctrl-a/e t
   org-insert-heading-respect-content t

   ;; Org styling, hide markup etc.
   org-hide-emphasis-markers t
   org-pretty-entities t))
#+END_SRC

enable src block guide in org-modern when using org-indent
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! org-modern-indent
  :recipe (:host github :repo "jdtsmith/org-modern-indent"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-modern-indent
  :config ; add late to hook
  (add-hook 'org-mode-hook #'org-modern-indent-mode 90))
#+END_SRC

** my take on modern divider: use space buffer divider instead of line divider

#+BEGIN_SRC emacs-lisp
(defvar modern-divider-enabled nil)

(defun modern-divider-on ()
  (modify-all-frames-parameters
   '((right-divider-width . 24)
     (internal-border-width . 24)))
  (dolist (face '(window-divider
                  window-divider-first-pixel
                  window-divider-last-pixel))
    (face-spec-reset-face face)
    (set-face-foreground face (face-attribute 'default :background)))
  (set-face-background 'fringe (face-attribute 'default :background)))

(defun modern-divider-off ()
  (modify-all-frames-parameters
   '((right-divider-width . 1)
     (internal-border-width . 1)))
  (dolist (face '(window-divider
                  window-divider-first-pixel
                  window-divider-last-pixel))
    (face-spec-reset-face face)
    (set-face-foreground face (face-attribute 'default :foreground)))
  (set-face-background 'fringe (face-attribute 'default :foreground))
  (doom/reload-theme))

(defun toggle-modern-divider ()
  "toggle modern divider, which uses space/margin to divide buffers instead of line"
  (interactive)
  (setq modern-divider-enabled (not modern-divider-enabled))
  (if modern-divider-enabled (modern-divider-on) (modern-divider-off)))
#+END_SRC

add a keybind
#+BEGIN_SRC emacs-lisp
(map! :leader "G" #'toggle-modern-divider)
#+END_SRC

** refile
#+BEGIN_SRC emacs-lisp
(setq org-refile-targets
      '((nil :maxlevel . 3)
        (org-agenda-files :maxlevel . 3)
        (all-org-files :maxlevel . 3)))
#+END_SRC

** journal
#+begin_src emacs-lisp
(setq org-journal-file-type 'monthly)
(setq org-journal-enable-agenda-integration t)
(setq org-capture-templates '(("j" "Journal entry" entry (function org-journal-find-location)
                               "* %(format-time-string org-journal-time-format)%^{Title}\n%i%?")))
#+end_src

** agenda and gtd system
*** priorities
#+begin_src emacs-lisp
(setq org-default-priority ?C)
(setq org-lowest-priority ?D)
(setq org-highest-priority ?A)
#+end_src

*** agenda helpers
#+BEGIN_SRC emacs-lisp
(defun air-org-skip-subtree-if-habit ()
  "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
  (let ((subtree-end (save-excursion (org-end-of-subtree t))))
    (if (string= (org-entry-get nil "STYLE") "habit")
        subtree-end
      nil)))

(defun air-org-skip-subtree-if-priority (priority)
  "Skip an agenda subtree if it has a priority of PRIORITY.
     PRIORITY may be one of the characters ?A, ?B, or ?C."
  (let ((subtree-end (save-excursion (org-end-of-subtree t)))
        (pri-value (* 1000 (- org-lowest-priority priority)))
        (pri-current (org-get-priority (thing-at-point 'line t))))
    (if (= pri-value pri-current)
        subtree-end
      nil)))

(defun chanining/archive-when-done ()
  "Archive current entry if it is marked as DONE"
  (when (org-entry-is-done-p)
    (org-toggle-archive-tag)))
#+END_SRC

*** agenda appearances
#+BEGIN_SRC emacs-lisp
(setq org-agenda-clockreport-parameter-plist
      (quote (:link t :maxlevel 3 :fileskip0 t :narrow 80 :formula %)))
(setq org-agenda-log-mode-items '(closed state clock))
(setq org-clock-idle-time 5)
;; (setq org-agenda-block-separator ?‚îÄ)
(setq org-agenda-block-separator " ")
(setq org-agenda-breadcrumbs-separator " ü°í ")
;; (setq my-org-agenda-prefix-format " %-2i %(concat \"[\" (car (last(split-string (or (org-agenda-get-category) \"\") \"-\"))) \"]\") %b %t%s")
(setq my-org-agenda-prefix-format " %-2i %b %t%s")
(setq org-agenda-sticky t)
#+END_SRC

*** todo-keywords
#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
'((sequence "TODO(t)" "PROJ(p)" "LOOP(r)" "STRT(s)" "WAIT(w)" "HOLD(h)" "IDEA(i)" "|" "DONE(d)" "KILL(k)")
 (sequence "[ ](T)" "[-](S)" "[?](W)" "|" "[X](D)")
 (sequence "|" "OKAY(o)" "YES(y)" "NO(n)"))
)
#+END_SRC

*** speed up org-mode
~org-roam~ encourages users to have a lot of files, since each file represent a zettel which encapsulate an atomic idea. This will slow down somethings.
#+BEGIN_SRC emacs-lisp
(setq org-inhibit-startup t)
(setq org-agenda-inhibit-startup t)
#+END_SRC

*** daily/weekly agenda format
#+begin_src emacs-lisp
(setq org-agenda-custom-commands
      '(
        ("d" "Daily agenda and all TODOs"
         (
          (todo "STRT"
                ((org-agenda-prefix-format my-org-agenda-prefix-format)
                 (org-agenda-todo-keyword-format "")
                 (org-agenda-remove-tags t)
                 (org-agenda-overriding-header "\n\n‚ö° Currently Doing:\n‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫")))

          (todo "PROJ"
                ((org-agenda-prefix-format my-org-agenda-prefix-format)
                 (org-agenda-todo-keyword-format "")
                 (org-agenda-remove-tags t)
                 (org-agenda-overriding-header "üí´ Projects:\n‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫")))

          (todo "LOOP"
                ((org-agenda-prefix-format my-org-agenda-prefix-format)
                 (org-agenda-todo-keyword-format "")
                 (org-agenda-remove-tags t)
                 (org-agenda-overriding-header "üï≥ Learning:\n‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫")))

          (todo "IDEA"
                ((org-agenda-prefix-format my-org-agenda-prefix-format)
                 (org-agenda-todo-keyword-format "")
                 (org-agenda-remove-tags t)
                 (org-agenda-overriding-header "üí° Ideas to Explore:\n‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫")))

          ;; CLOCK REPROT
          (agenda "" (
                      (org-agenda-start-day "+0d")
                      (org-agenda-span 2)
                      (org-agenda-overriding-header " üóì Schedule:\n‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫")
                      ;; (org-agenda-repeating-timestamp-show-all nil)
                      (org-agenda-remove-tags t)
                      (org-agenda-prefix-format   "  %-2i %t %s  ")
                      ;; (org-agenda-prefix-format " %-2i %b %t%s")
                      ;; (org-agenda-todo-keyword-format " ‚òê ")
                      (org-agenda-current-time-string "‚≠† now ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
                      (org-agenda-scheduled-leaders '("" ""))
                      (org-agenda-time-grid  '((daily today remove-match)
                                               (800 1000 1200 1400 1600 1800 2000)
                                               " ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ " "‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ"))))

          (todo "TODO"
                ((org-agenda-prefix-format my-org-agenda-prefix-format)
                 (org-agenda-todo-keyword-format "")
                 (org-agenda-remove-tags t)
                 (org-agenda-overriding-header "üì• Inbox:\n‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫")))


          (todo "WAIT"
                ((org-agenda-skip-function '(or (air-org-skip-subtree-if-habit)
                                                (air-org-skip-subtree-if-priority ?A)
                                                (org-agenda-skip-if nil '(scheduled deadline))))
                                                
                 (org-agenda-prefix-format my-org-agenda-prefix-format)
                 (org-agenda-todo-keyword-format "")
                 (org-agenda-remove-tags t)
                 (org-agenda-overriding-header "ü§î Do these next:\n‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫")))

          (todo "HOLD"
                ((org-agenda-skip-function '(or (air-org-skip-subtree-if-habit)
                                                (air-org-skip-subtree-if-priority ?A)
                                                (org-agenda-skip-if nil '(scheduled deadline))))
                                                
                 (org-agenda-prefix-format my-org-agenda-prefix-format)
                 (org-agenda-todo-keyword-format "")
                 (org-agenda-remove-tags t)
                 (org-agenda-overriding-header "üìí Archive:\n‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫"))))

          


         ((org-agenda-compact-blocks nil)
          (org-agenda-archives-mode t)
          (org-agenda-start-with-log-mode t)
          (org-agenda-start-with-clockreport-mode t)
          (org-agenda-start-on-weekday 1)))

        ("w" "Weekly review"
         agenda ""
         ((org-agenda-span 'week)
          (org-agenda-start-on-weekday 1)
          (org-agenda-start-with-log-mode t)
          (org-agenda-start-with-clockreport-mode t)
          (org-agenda-archives-mode t)
          (org-agenda-prefix-format " %-2i %t %s %b ")))))
          
#+end_src


*** weekly time report review mode
#+begin_src emacs-lisp
(defun my-org-agenda-time-grid-spacing ()
  "Set different line spacing w.r.t. time duration."
  (save-excursion
    (let ((colors (list "IndianRed" "SeaGreen4" "sienna3" "DarkSlateGray4"))
          pos
          duration)
      (nconc colors colors)
      (goto-char (point-min))
      (while (setq pos (next-single-property-change (point) 'duration))
        (goto-char pos)
        (when (and (not (equal pos (point-at-eol)))
                   (setq duration (org-get-at-bol 'duration)))
          (let ((line-height (if (< duration 30) 1.0 (+ 0.5 (/ duration 60))))
                (ov (make-overlay (point-at-bol) (1+ (point-at-eol)))))
            (overlay-put ov 'face `(:background ,(car colors) :foreground "#FFFFFF"))
            (setq colors (cdr colors))
            (overlay-put ov 'line-height line-height)
            (overlay-put ov 'line-spacing (1- line-height))))))))
#+end_src

*** agenda category icon list
#+begin_src emacs-lisp
(setq org-agenda-category-icon-alist
      `(
        (".*gtd.*" ,(list (all-the-icons-faicon "pencil")) nil nil :ascent center)
        (".*research.*" ,(list (all-the-icons-octicon "mortar-board")) nil nil :ascent center)
        (".*sail.*" ,(list (all-the-icons-octicon "briefcase")) nil nil :ascent center)
        (".*game_ai.*" ,(list (all-the-icons-octicon "briefcase")) nil nil :ascent center)
        (".*neuri.*" ,(list (all-the-icons-octicon "briefcase")) nil nil :ascent center)
        (".*career.*" ,(list (all-the-icons-octicon "briefcase")) nil nil :ascent center)
        (".*math.*" ,(list (all-the-icons-octicon "mortar-board")) nil nil :ascent center)
        (".*ai4sci.*" ,(list (all-the-icons-octicon "mortar-board")) nil nil :ascent center)
        (".*phd_application.*" ,(list (all-the-icons-octicon "mortar-board")) nil nil :ascent center)
        (".*reinforcement_learning.*" ,(list (all-the-icons-octicon "mortar-board")) nil nil :ascent center)
        (".*cvx.*" ,(list (all-the-icons-octicon "mortar-board")) nil nil :ascent center)
        (".*geometry.*" ,(list (all-the-icons-octicon "mortar-board")) nil nil :ascent center)
        (".*quantum.*" ,(list (all-the-icons-octicon "mortar-board")) nil nil :ascent center)
        (".*nus.*" ,(list (all-the-icons-octicon "mortar-board")) nil nil :ascent center)
        (".*MA.*" ,(list (all-the-icons-octicon "mortar-board")) nil nil :ascent center)
        (".*music.*" ,(list (all-the-icons-faicon "music")) nil nil :ascent center)
        (".*health.*" ,(list (all-the-icons-octicon "pulse")) nil nil :ascent center)
        (".*habit.*" ,(list (all-the-icons-octicon "pulse")) nil nil :ascent center)
        (".*workouts.*" ,(list (all-the-icons-octicon "pulse")) nil nil :ascent center)
        (".*nutrition.*" ,(list (all-the-icons-octicon "pulse")) nil nil :ascent center)
        (".*mindfulness.*" ,(list (all-the-icons-octicon "pulse")) nil nil :ascent center)
        ;; ("my_fin" ,(list (all-the-icons-faicon "usd")) nil nil :ascent center)
        (".*fin.*" ,(list (all-the-icons-faicon "line-chart" :height 0.68)) nil nil :ascent center)
        (".*ml.*" ,(list (all-the-icons-octicon "hubot")) nil nil :ascent center)
        (".*productivity.*" ,(list (all-the-icons-faicon "terminal")) nil nil :ascent center)
        (".*cs.*" ,(list (all-the-icons-faicon "terminal")) nil nil :ascent center)
        (".*cpp.*" ,(list (all-the-icons-faicon "terminal")) nil nil :ascent center)
        ;; (".*schedule.*" ,(list (all-the-icons-faicon "commenting")) nil nil :ascent center)
        (".*schedule.*" ,(list (all-the-icons-octicon "calendar")) nil nil :ascent center)
        (".*blockchain.*" ,(list (all-the-icons-faicon "lock")) nil nil :ascent center)
        ("vocab" ,(list (all-the-icons-faicon "book")) nil nil :ascent center)
        (".*read.*" ,(list (all-the-icons-faicon "book")) nil nil :ascent center)
        (".*cooking.*" ,(list (all-the-icons-faicon "fire")) nil nil :ascent center)
        (".*" ,(list (all-the-icons-faicon "check")) nil nil :ascent center)
        ))
#+end_src

** writeroom mode
#+begin_src emacs-lisp
(add-hook 'org-agenda-finalize-hook #'set-window-clean)

;; use percentage to calculate left/right margin instead of the default 80 char line width
(setq writeroom-width 0.8)

(defun set-window-clean ()
  "clean buffer for org agenda"
  (interactive)
  (setq mode-line-format nil)
  (writeroom-mode)
  (text-scale-decrease 2)
  (my-org-agenda-time-grid-spacing))
#+end_src

** auto export org beamer
#+begin_src emacs-lisp
(defun my-org-beamer-sync-hook ()
  (when (eq major-mode 'org-mode)
    (if (and (boundp 'org-latex-classes)
             (equal (car org-file-tags) #("presentation" 0 12 (inherited t))))
        (org-beamer-export-to-latex))))

(add-hook 'before-save-hook #'my-org-beamer-sync-hook)
#+end_src

** keybinds
#+BEGIN_SRC emacs-lisp
(add-hook! 'org-mode-hook
  (spacemacs/set-leader-keys-for-major-mode 'org-mode
    "I" 'org-clock-in
    "O" 'org-clock-out
    "R" 'org-refile))

(map! :n "na" 'org-agenda)
#+END_SRC

* Research Workflow
So what is =research= anyway? It is the =compression= of information by human brain. There are two kinds of =compression=:
1. compression of inputs: people also call this =insight=.
2. compression of input / output pairs: people also call this =discovery=

** paths
I will use Dropbox as this provides integration with Overleaf.
#+BEGIN_SRC emacs-lisp
(defconst my-bib-libraries (list "~/Dropbox/Apps/Overleaf/lib.bib")) ; bib databases.
(defconst my-main-bib-library (nth 0 my-bib-libraries))              ; The main db is always the first
(defconst my-main-pdfs-library-paths `("~/Dropbox/bib/papers/inbox/" "~/Dropbox/bib/papers/read/" "~/Dropbox/bib/papers/cited/" "~/Dropbox/bib/textbooks/"))
(defconst my-main-pdfs-library-path (nth 0 my-main-pdfs-library-paths))
(defconst my-bib-notes-dir "~/Dropbox/notes/roam")
(setq bibtex-completion-bibliography my-bib-libraries
      bibtex-completion-library-path my-main-pdfs-library-paths
      bibtex-completion-notes-path my-bib-notes-dir
      bibtex-completion-pdf-open-function (lambda (fpath)
                                             (call-process "open" nil 0 nil fpath)))
(setq citar-library-paths my-main-pdfs-library-paths)
(setq citar-notes-paths my-main-pdfs-library-paths)
(setq citar-org-roam-subdir "research")
(setq org-noter-notes-search-path '("~/Dropbox/notes/roam/research"))
#+END_SRC

** information acquisition
*** TODO twitter
*** RSS: elfeed
**** RSS feeds
#+BEGIN_SRC emacs-lisp
(defun arxiv-rss-feed-url (cat &optional max-results sort-by sort-order)
  "Search for CAT"
  (unless max-results (setq max-results "100"))
  (unless sort-by (setq sort-by "submittedDate"))
  (unless sort-order (setq sort-order "descending"))
  (append
   (concat
   "http://export.arxiv.org/api/query?search_query=cat:" cat
   "&start=0&max_results=" max-results
   "&sortBy=" sort-by
   "&sortOrder=" sort-order)
   )
  )

(setq arxiv-feeds-funcs
      '(((arxiv-rss-feed-url "math.OC") math optimization control)
       ((arxiv-rss-feed-url "stat.ML") stats machine-learning )
       ((arxiv-rss-feed-url "cs.LG") cs machine-learning)
       ))

(setq arxiv-feeds
      (mapcar
       (lambda (x) (append (list (eval (car x))) (cdr x)))
       arxiv-feeds-funcs))

(setq acs-feeds  '(("https://feeds.feedburner.com/acs/jacsat" chemistry jacs)
                   ("https://feeds.feedburner.com/acs/jctcce" theory computation jctc)))
(setq elfeed-feeds (append arxiv-feeds acs-feeds))
#+END_SRC

**** feed scoring
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! elfeed-score)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package elfeed-score
  :after elfeed
  :config
  (elfeed-score-load-score-file "~/dotfiles/elfeed/elfeed.score")
  (elfeed-score-enable)
  (define-key elfeed-search-mode-map "=" elfeed-score-map))
#+END_SRC

**** feed formatting
#+BEGIN_SRC emacs-lisp
(use-package! elfeed
  :config
  (add-hook! 'elfeed-search-mode-hook #'elfeed-update)

  (defun concatenate-authors (authors-list)
    "Given AUTHORS-LIST, list of plists; return string of all authors concatenated."
    (if (> (length authors-list) 1)
        (format "%s et al." (plist-get (nth 0 authors-list) :name))
      (plist-get (nth 0 authors-list) :name)))

  (defun my-search-print-fn (entry)
    "Print ENTRY to the buffer."
    (let* ((date (elfeed-search-format-date (elfeed-entry-date entry)))
           (title (or (elfeed-meta entry :title)
                      (elfeed-entry-title entry) ""))
           (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
           (entry-authors (concatenate-authors (elfeed-meta entry :authors)))
           (title-width (- (window-width) 10 elfeed-search-trailing-width))
           (title-column (elfeed-format-column title 100 :left))
           (entry-score (elfeed-format-column (number-to-string (elfeed-score-scoring-get-score-from-entry entry)) 10 :left))
           (authors-column (elfeed-format-column entry-authors 40 :left)))
      (insert (propertize date 'face 'elfeed-search-date-face) " ")
      (insert (propertize title-column 'face title-faces 'kbd-help title) " ")
      (insert (propertize authors-column 'kbd-help entry-authors) " ")
      (insert entry-score " ")
    ))

  (setq elfeed-search-print-entry-function #'my-search-print-fn)
  (setq elfeed-search-date-format '("%y-%m-%d" 10 :left))
  (setq elfeed-search-title-max-width 110)
  (setq elfeed-search-filter "@2-week-ago")
)
#+END_SRC

**** arxiv paper fetcher
#+BEGIN_SRC emacs-lisp
(defun my-elfeed-entry-to-arxiv ()
  "Fetch an arXiv paper into the local library from the current elfeed entry."
  (interactive)
  (let* ((link (elfeed-entry-link elfeed-show-entry))
         (match-idx (string-match "arxiv.org/abs/\\([0-9.]*\\)" link))
         (matched-arxiv-number (match-string 1 link)))
    (when matched-arxiv-number
      (message "Going to arXiv: %s" matched-arxiv-number)
      (arxiv-get-pdf-add-bibtex-entry matched-arxiv-number my-main-bib-library my-main-pdfs-library-path)
      )
    ))
#+END_SRC

*** offline PDF: biblio
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! biblio)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq biblio-download-directory "~/Dropbox/Library/")
(setq citar-bib "~/Dropbox/Apps/Overleaf/lib.bib")

(defun biblio-current-buffer ()
  "Call an interactive function with the current buffer name."
  (interactive)
  (let ((query (buffer-name)))
    (biblio-lookup nil (string-remove-suffix ".pdf" query))))

(defun paste-to-citar-lib ()
  "Paste the current clipboard contents to a specific file."
  (interactive)
  ;; Ensure the kill ring is not empty
  (if (and kill-ring (not (string= "" (current-kill 0))))
      (let ((content (current-kill 0)))
        (with-temp-buffer
          (when (file-exists-p citar-bib)
            (insert-file-contents citar-bib))
          (goto-char (point-max))
          (insert content)
          (write-file citar-bib)))
    (message "Clipboard is empty.")))
#+END_SRC

*** web: zotra
workflow:
1. copy url in chrome (yy)
2. use XMonad to invoke `zotra-add-entry-and-pdf-from-url`
3. go through the options, in the end open the downloaded pdf
4. SPC C A to attach the pdf to the citar entry
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/dotfiles/doom/zotra")
(require 'zotra)
#+END_SRC

clean entry with org-ref after adding an entry
#+BEGIN_SRC emacs-lisp
(add-hook 'zotra-after-add-entry-hook 'org-ref-clean-bibtex-entry)
#+END_SRC

add entry then put the attachment in the right place
#+BEGIN_SRC emacs-lisp
(defun zotra-add-entry-and-pdf-from-url (url)
(interactive
   (list (read-string
          "url: "
          (ignore-errors (current-kill 0 t)))))
  (zotra-add-entry-from-url url citar-bib nil)
  (zotra-open-attachment-from-url url "/tmp")
  )
#+END_SRC

** information storage
*** org-ref
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! org-ref)
#+END_SRC

*** citar
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! citar)
(package! citar-embark)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package! citar
  ;; :hook (doom-after-init-modules . citar-refresh)
  :custom
  (citar-bibliography '("~/Dropbox/Apps/Overleaf/lib.bib"))
  :hook
  (LaTeX-mode . citar-capf-setup)
  (org-mode . citar-capf-setup)
  :config
  ;; This will add watches for the global bib files and in addition add a hook to LaTeX-mode-hook and org-mode-hook to add watches for local bibliographic files.
  ;; (citar-filenotify-setup '(LaTeX-mode-hook org-mode-hook))

  (require 'citar-org)
  (setq citar-file-extensions '("pdf" "org" "md")
        citar-file-open-function #'find-file)

  ;; by default citar store file as something like 2017.pdf, which is not really readable
  (defun my-citar-full-names (names)
    "Transform names like LastName, FirstName to FirstName LastName."
    (when (stringp names)
      (mapconcat
       (lambda (name)
         (if (eq 1 (length name))
             (split-string name " ")
           (let ((split-name (split-string name ", ")))
             (cl-concatenate 'string (nth 1 split-name) " " (nth 0 split-name)))))
       (split-string names " and ") ", ")))

  (setq citar-display-transform-functions
        '((("author" "editor") . my-citar-full-names)))

  (setq citar-templates
        '((main . "${author editor:55}     ${date year issued:4}     ${title:55}")
          (suffix . "  ${tags keywords keywords:40}")
          (preview . "${author editor} ${title}, ${journal publisher container-title collection-title booktitle} ${volume} (${year issued date}).\n")
          (note . "#+title: Notes on ${author editor}, ${title}")))

  )

(use-package citar-embark
  :after citar embark
  :no-require
  :config (citar-embark-mode))
#+END_SRC
*** for existing PDFs, add it to citar directly
#+BEGIN_SRC emacs-lisp
;;;###autoload
(defun citar-add-current-buffer-to-library (citekey)
  "Add a file to the library for CITEKEY.
The FILE can be added from an open buffer, a file path, or a
URL."
  (interactive (list (citar-select-ref)))
  (citar--check-configuration 'citar-library-paths)
  (unless citar-library-paths
    (user-error "Make sure `citar-library-paths' is non-nil"))
  (let* ((directory (if (cdr citar-library-paths)
                        (completing-read "Directory: " citar-library-paths)
                      (car citar-library-paths)))
         (filepath (expand-file-name citekey directory))
         (withext (lambda (extension)
                    (let* ((extension (or extension (read-string "File extension: "))))
                      (if (string-empty-p extension)
                          filepath
                        (concat filepath "." extension))))))
    (with-current-buffer (read-buffer "Add file buffer: " (current-buffer))
      (let ((destfile (funcall withext (and buffer-file-name (file-name-extension buffer-file-name)))))
        (write-file destfile 'confirm)))
    ))
#+END_SRC

*** create reading task from citar entry: org-roam-bibtex
workflow:
1. SPC C O: open an citar entry
2. M-o: embark
3. C: create reading task using the template below

#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! org-roam-bibtex)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package! org-roam-bibtex
  :config
  (setq org-roam-capture-templates
        '(("d" "default" plain "%?"
               :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
               :unnarrowed t)
          ("i" "research-quick" entry
           "* TODO %?"
           :target (node "3b5d0d92-c6bb-4832-ae7a-cdc2e473ff58")
           :empty-lines-before 1
           :prepend t
           :unnarrowed t)
          ("r" "research" entry
           "* What %?\n* Why \n* How \n* Reading List\n* Ideas"
           :target (file+head "research/${slug}.org" "#+title: ${title}\n")
           :unnarrowed t)
          ("p" "paper" entry
           "* TODO [cite:@%^{citekey}] :paper:\n%? "
           :target (node "3b5d0d92-c6bb-4832-ae7a-cdc2e473ff58")
           :unnarrowed t
           :empty-lines-before 1
           :prepend t)))

  (require 'org-roam-bibtex)

  (setq citar-open-note-function 'orb-citar-edit-note
        orb-preformat-keywords '("citekey" "title" "url" "author-or-editor" "keywords" "file")
        orb-process-file-keyword t
        orb-file-field-extensions '("pdf"))
)

(add-hook! org-roam (org-roam-bibtex t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun org-roam-capture-research-quick ()
    "Capture a TODO straight to the inbox."
    (interactive)
    (org-roam-capture- :goto nil
                       :keys "i"
                       :node (org-roam-node-from-id "3b5d0d92-c6bb-4832-ae7a-cdc2e473ff58")))

(defun org-roam-capture-bib ()
  "Capture using the reading task template."
  (interactive)
  (org-roam-capture- :goto nil
                     :keys "p"
                     :node (org-roam-node-from-id "3b5d0d92-c6bb-4832-ae7a-cdc2e473ff58")))

(map! (:after citar (:map citar-map "C" #'org-roam-capture-bib)))
#+END_SRC

** information processing
1. taking plain text note with org-roam-bibtex
2. taking note pinned to the associated PDF with org-noter
*** annotate pdf: org-noter + org-pdftools
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! org-pdftools)
(package! org-noter-pdftools)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-noter
  :config
  (add-hook! 'org-noter-doc-mode-hook (evil-local-mode))
  (require 'org-noter-pdftools))

(use-package org-pdftools
  :hook (org-mode . org-pdftools-setup-link))
(use-package org-noter-pdftools
  :after org-noter
  :config
  ;; Add a function to ensure precise note is inserted
  (defun org-noter-pdftools-insert-precise-note (&optional toggle-no-questions)
    (interactive "P")
    (org-noter--with-valid-session
     (let ((org-noter-insert-note-no-questions (if toggle-no-questions
                                                   (not org-noter-insert-note-no-questions)
                                                 org-noter-insert-note-no-questions))
           (org-pdftools-use-isearch-link t)
           (org-pdftools-use-freepointer-annot t))
       (org-noter-insert-note (org-noter--get-precise-info)))))

  ;; fix https://github.com/weirdNox/org-noter/pull/93/commits/f8349ae7575e599f375de1be6be2d0d5de4e6cbf
  (defun org-noter-set-start-location (&optional arg)
    "When opening a session with this document, go to the current location.
With a prefix ARG, remove start location."
    (interactive "P")
    (org-noter--with-valid-session
     (let ((inhibit-read-only t)
           (ast (org-noter--parse-root))
           (location (org-noter--doc-approx-location (when (called-interactively-p 'any) 'interactive))))
       (with-current-buffer (org-noter--session-notes-buffer session)
         (org-with-wide-buffer
          (goto-char (org-element-property :begin ast))
          (if arg
              (org-entry-delete nil org-noter-property-note-location)
            (org-entry-put nil org-noter-property-note-location
                           (org-noter--pretty-print-location location))))))))
  (with-eval-after-load 'pdf-annot
    (add-hook 'pdf-annot-activate-handler-functions #'org-noter-pdftools-jump-to-note)))
#+END_SRC

*** writing notes: LaTeX
**** powerful snippet: laas
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! laas
  :recipe (:host github :repo "tecosaur/LaTeX-auto-activating-snippets"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package laas
  :hook (LaTeX-mode . laas-mode)
        (org-auctex-mode . laas-mode)
  :config ; do whatever here
  (aas-set-snippets 'laas-mode
                    ;; set condition!
                    :cond #'texmathp ; expand only while in math
                    "supp" "\\supp"
                    "On" "O(n)"
                    "O1" "O(1)"
                    "Olog" "O(\\log n)"
                    "Olon" "O(n \\log n)"
                    ;; bind to functions!
                    "Sum" (lambda () (interactive)
                            (yas-expand-snippet "\\sum_{$1}^{$2} $0"))
                    "Span" (lambda () (interactive)
                             (yas-expand-snippet "\\Span($1)$0"))
                    ;; add accent snippets
                    :cond #'laas-object-on-left-condition
                    "qq" (lambda () (interactive) (laas-wrap-previous-object "sqrt"))))

(add-hook! 'tex-mode-hook (laas-mode t))
(add-hook! 'org-auctex-hook (laas-mode t))
#+END_SRC

**** pdf should auto revert
#+BEGIN_SRC emacs-lisp
(add-hook 'pdf-view-mode-hook 'auto-revert-mode)
#+END_SRC

**** fast latex preview in org: org-auctex
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "packages.el") "no")
(package! auctex)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/dotfiles/doom/org-auctex")
(require 'org-auctex)
#+END_SRC

reload preview when saved
#+BEGIN_SRC emacs-lisp
(add-hook! 'after-save-hook
    (when (bound-and-true-p org-auctex-mode)
      (org-auctex-preview-dwim)))
#+END_SRC

hooks for nice visual
#+BEGIN_SRC emacs-lisp
(add-hook! org-auctex-mode
  (variable-pitch-mode t)
  (visual-fill-column-mode t)
  (setq visual-fill-column-width 132)
  (org-auctex-preview-buffer))
#+END_SRC

keybinds
#+BEGIN_SRC emacs-lisp
(map! :leader
  "A" #'org-auctex-mode
  "P" #'org-auctex-preview-dwim)
#+END_SRC

** keybinds
*** elfeed keybinds (SPC n)
#+BEGIN_SRC emacs-lisp
(map! (:after elfeed
       (:map elfeed-search-mode-map
        :desc "Open entry" "m" #'elfeed-search-show-entry)
       (:map elfeed-show-mode-map
        :desc "Fetch arXiv paper to the local library" "a" #'my-elfeed-entry-to-arxiv)))

(map! :leader
      :desc "arXiv paper to library" "n x" #'arxiv-get-pdf-add-bibtex-entry
      :desc "Elfeed" "n e" #'elfeed)
#+END_SRC


*** citar / org-roam(-bibtex) keybinds (SPC C)

create a reading task from a citar entry:
1. (SPC C O) to open the entry
2. (M-o) to embark, and select open-notes

#+BEGIN_SRC emacs-lisp
(map!
 (:after citar
  (:leader
   :n "CC" #'org-roam-capture-research-quick
   :n "CO" #'citar-open
   :n "CA" #'citar-add-current-buffer-to-library
   :n "CP" #'paste-to-citar-lib)))
#+END_SRC

*** pdf keybinds (,)
#+BEGIN_SRC emacs-lisp
(map!
 (:after pdf-tools
   (:map pdf-view-mode-map
    :localleader
    "b" #'biblio-lookup
    "N" #'org-noter
    "S" #'org-noter-pdftools-create-skeleton
    "q" #'org-noter-kill-session)

   ;; custom evil like keymap
   (:map org-noter-doc-mode-map
    "j" #'org-noter-sync-next-note
    "k" #'org-noter-sync-prev-note
    "C-u" #'org-noter-sync-next-note
    "C-d" #'org-noter-sync-prev-note
    "zz" #'org-noter-sync-current-note)))
#+END_SRC

*** bib keybinds (,)
#+BEGIN_SRC emacs-lisp
(map!
 (:after bibtex
   (:map bibtex-mode-map
     :localleader
     "f" #'org-ref-clean-bibtex-entry)))
#+END_SRC

* Email
** mu4e
make popup nicer
#+BEGIN_SRC emacs-lisp
(set-popup-rule! "*mu4e-main*" :size 0.95 :side 'bottom :vslot 1 :ttl nil :select t :modeline nil :quit nil)
(set-popup-rule! "*mu4e-headers*" :size 0.95 :side 'bottom :vslot 1 :ttl nil :select t :modeline nil :quit nil)
(set-popup-rule! "*mu4e-article*" :size 0.75 :side 'bottom :vslot 2 :ttl nil :select nil :modeline nil :quit nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package mu4e
  :defer t
  :config
  (setq mu4e-update-interval (* 5 60)))
#+END_SRC

** msmtp
#+BEGIN_SRC emacs-lisp
(after! mu4e
  (setq sendmail-program (executable-find "msmtp")
        send-mail-function #'smtpmail-send-it
        message-sendmail-f-is-evil t
        message-sendmail-extra-arguments '("--read-envelope-from")
        message-send-mail-function #'message-send-mail-with-sendmail))
#+END_SRC

** keybinds
#+BEGIN_SRC emacs-lisp
(map! :leader "EE" 'mu4e)
#+END_SRC

* Calendar
#+BEGIN_SRC emacs-lisp
(defun my-open-calendar ()
  (interactive)
  (cfw:open-calendar-buffer
   :contents-sources
   (list
    (cfw:org-create-source "steel blue")  ; orgmode source
    (cfw:ical-create-source "gcal" sail-gcal "sea green")
    (cfw:ical-create-source "gcal" my-gcal "IndianRed")))) ; google calendar ICS

(defun my--cfw:open-calendar-buffer-view (orig-func &rest args &allow-other-keys)
  (apply orig-func :view 'two-weeks :allow-other-keys t args)
  )
(advice-add 'cfw:open-calendar-buffer :around #'my--cfw:open-calendar-buffer-view)
#+END_SRC

** keybind
#+BEGIN_SRC emacs-lisp
(map! (:leader :n "W" 'my-open-calendar))
#+END_SRC
* Other Keybinds
** cursor and window movements
#+begin_src emacs-lisp
(map!

 :v "s" #'evil-surround-region
 :o "S" #'evil-surround-edit
 :n "]e" #'move-text-line-down
 :n "[e" #'move-text-line-up

 :nv "M-n" #'evil-mc-make-and-goto-next-match
 :nv "M-p" #'evil-mc-make-and-goto-prev-match
 (:map evil-mc-cursor-map
  :nv "M-n" #'evil-mc-make-and-goto-next-match
  :nv "M-p" #'evil-mc-make-and-goto-prev-match
 )
 (:map evil-mc-key-map
  :nv "M-n" #'evil-mc-make-and-goto-next-match
  :nv "M-p" #'evil-mc-make-and-goto-prev-match
 )

 (:leader
  :n "RET" 'bookmark-jump

  ;; workspace / window management
  :n "o" 'spacemacs/workspaces-transient-state/body
  :n "0" 'treemacs-select-window
  :n "1" 'winum-select-window-1
  :n "2" 'winum-select-window-2
  :n "3" 'winum-select-window-3
  :n "4" 'winum-select-window-4
  :n "5" 'winum-select-window-5
  :n "6" 'winum-select-window-6
  :n "7" 'winum-select-window-7
  :n "8" 'winum-select-window-8
  :n "9" 'winum-select-window-9

  ;; jumps
  :n "ji" 'imenu
  :n "." 'evil-goto-definition
  :n "bb" 'switch-to-buffer)

)

;; Make evil-mode up/down operate in screen lines instead of logical lines
(define-key evil-motion-state-map "j" 'evil-next-visual-line)
(define-key evil-motion-state-map "k" 'evil-previous-visual-line)

;; Also in visual mode
(define-key evil-visual-state-map "j" 'evil-next-visual-line)
(define-key evil-visual-state-map "k" 'evil-previous-visual-line)
#+end_src

** searching and completion
#+BEGIN_SRC emacs-lisp
(map!
 "C-s" 'consult-line
 "C-c C-s" '+vertico/search-symbol-at-point
 "C-c s" 'consult-ripgrep
)
#+END_SRC

** misc
#+BEGIN_SRC emacs-lisp
(map! (:leader
  :n "es" 'flycheck-list-errors
  :n "gs" 'magit-status
  :n "gff" 'magit-find-file
  :n "Ts" 'load-theme
))
#+END_SRC

** spacemacs leader
#+BEGIN_SRC emacs-lisp
(setq doom-localleader-key ",")
#+END_SRC

* Org agenda as starting page for emacs client
#+BEGIN_SRC emacs-lisp
(defun emacs-startup-screen ()
  "display the weekly org-agenda and all todos. used for client mode"
  (find-file "~/Dropbox/notes/roam/research/entry_point.org")
  (org-agenda nil "d"))
#+END_SRC

* EAF
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/dotfiles/doom/emacs-application-framework/")
(require 'eaf)

(use-package eaf
  :custom
  (eaf-browser-continue-where-left-off t)
  (eaf-browser-enable-adblocker t)
  (browse-url-browser-function 'eaf-open-browser)
  :config
  (require 'eaf-browser)
  (defalias 'browse-web #'eaf-open-browser)
  (setq eaf-webengine-default-zoom 1.5)
  (eaf-bind-key nil "SPC" eaf-browser-keybinding)
  (eaf-bind-key nil "M-q" eaf-browser-keybinding)) ;; unbind, see more in the Wiki
#+END_SRC

** use ~doom-modeline~

** helper function: open ~ibuffer~ with all EAF buffers
#+BEGIN_SRC emacs-lisp
(defun eaf-ibuffer ()
  "Open `ibuffer` with only EAF buffers."
  (interactive)
  (ibuffer)
  (ibuffer-filter-by-mode 'eaf-mode))
#+END_SRC

** keybinds
#+BEGIN_SRC emacs-lisp
(map! (:leader
       :n "O" 'eaf-open-browser-with-history
       :n "B" 'eaf-ibuffer))
#+END_SRC
