#+TITLE: Configuration
#+AUTHOR: Zekun Shi
#+PROPERTY: header-args :emacs-lisp :comments link
#+STARTUP: org-startup-folded: showall
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-
#+END_SRC

* Auth Info
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Zekun Shi"
      user-mail-address "derek.zekun.shi@gmail.com")
#+END_SRC

* Better Defaults
** shorten wait time
#+BEGIN_SRC emacs-lisp
(setq auto-revert-interval 0.5)
#+END_SRC

* Visual Settings
** themes

*** Use light / dark theme based on current time: circadian
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "package.el") "no")
(package! circadian)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package! circadian
  :ensure t
  :config
  (setq circadian-themes '(("8:00" . doom-flatwhite)
                           ("18:30" . kanagawa)))
  (circadian-setup))
#+END_SRC

*** more themes
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "package.el") "no")
(package! autothemer)
(package! doom-alabaster-theme :recipe (:host github :repo "agraul/doom-alabaster-theme"))
#+END_SRC

** line number
No line number.
#+BEGIN_SRC emacs-lisp
(setq display-line-numbers-type nil)
#+END_SRC

** disable hl-line-mode in rainbow-mode
#+BEGIN_SRC emacs-lisp
(add-hook! 'rainbow-mode-hook
  (hl-line-mode (if rainbow-mode -1 +1)))
#+END_SRC

** set font sizes based on dpi
We use the following shell command to get current dpi as ~x-display-pixel-width~ does not work in server mode.
#+BEGIN_SRC emacs-lisp
(defun get-current-dpi ()
  (string-to-number (shell-command-to-string "xrdb -query | grep dpi | awk '{print $2}'")))

(if (= (get-current-dpi) 116)

  ;; laptop
  (setq doom-font (font-spec :family "Iosevka Term SS04" :size 20 :dpi 116)
        doom-variable-pitch-font (font-spec :family "Iosevka" :dpi 116)
        doom-unicode-font (font-spec :family "Iosevka Term SS04" :dpi 116)
        doom-big-font (font-spec :family "Iosevka Term SS04" :size 26 :dpi 116))

  ;; monitor
  (setq doom-font (font-spec :family "Iosevka Term SS04" :size 26 :dpi 163)
        doom-variable-pitch-font (font-spec :family "Iosevka" :dpi 163)
        doom-unicode-font (font-spec :family "Iosevka Term SS04" :dpi 163)
        doom-big-font (font-spec :family "Iosevka Term SS04" :size 32 :dpi 163)))
#+END_SRC

* File manager: Dired / Ranger
** image preview
don't know why ranger's preview is not working
#+BEGIN_SRC emacs-lisp
(define-minor-mode dired-follow-mode
  "Diplay file at point in dired after a move."
  :lighter " dired-f"
  :global t
  (if dired-follow-mode
      (advice-add 'dired-next-line :after (lambda (arg) (dired-display-file)))
    (advice-remove 'dired-next-line (lambda (arg) (dired-display-file)))))
#+END_SRC

** yank buffer name
#+BEGIN_SRC emacs-lisp
(defun yank-buffer-file-name ()
  "Copy the current buffer's file name to the kill ring."
  (interactive)
  (if-let ((name (buffer-file-name)))
      (progn
        (kill-new name)
        (message "Buffer file name '%s' copied to clipboard" name))
    (message "Current buffer is not visiting a file")))

(map! "C-c n" 'yank-buffer-file-name)
#+END_SRC

** load large file in chunks: vlf
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "package.el") "no")
(package! vlf)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package! vlf
  :defer-incrementally vlf-tune vlf-base vlf-write vlf-search vlf-occur vlf-follow vlf-ediff vlf)
#+END_SRC

** keybinds
#+BEGIN_SRC emacs-lisp
(map! :after ranger
      (:map ranger-mode-map
          "i" 'dired-follow-mode
          "C-c C-o" #'ranger-open-file-other-window
          ))
#+END_SRC

* Terminal: Vterm
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "package.el") "no")
(package! multi-vterm)                  ;; for multiple vterms
(package! shell-pop)
#+END_SRC

** make auto-complete visible
#+BEGIN_SRC emacs-lisp
(setq shell-file-name "/bin/zsh")
(custom-set-faces! '(vterm-color-black :background "#839496"))
#+END_SRC
** more scroll back
#+BEGIN_SRC emacs-lisp
(setq vterm-max-scrollback 100000)
#+END_SRC

** send code
NOTE: need to disable ~read-only-mode~
#+BEGIN_SRC emacs-lisp
(defun sh-send-line-or-region (&optional step)
  (interactive ())
  (let ((proc (get-process "vterm"))
        pbuf min max command)
    (unless proc
      (let ((currbuff (current-buffer)))
        (shell)
        (switch-to-buffer currbuff)
        (setq proc (get-process "vterm"))))

    (setq pbuff (process-buffer proc))
    (if (use-region-p)
        (setq min (region-beginning)
              max (region-end))
      (setq min (point-at-bol)
            max (point-at-eol)))
    (setq command (concat (buffer-substring min max) "\n"))
    (with-current-buffer pbuff
      (goto-char (process-mark proc))
      (insert command)
      (move-marker (process-mark proc) (point)))
       ;;pop-to-buffer does not work with save-current-buffer -- bug?
    (process-send-string  proc command)
    (display-buffer (process-buffer proc) t)
    (when step
      (goto-char max)
      (next-line))))


(defun sh-send-line-or-region-and-step ()
  (interactive)
  (sh-send-line-or-region t))

(defun sh-switch-to-process-buffer ()
  (interactive)
  (pop-to-buffer (process-buffer (get-process "vterm")) t))
#+END_SRC

** keybinds
#+BEGIN_SRC emacs-lisp
(map!
 :leader
 :n "'" 'spacemacs/shell-pop-multi-vterm
 (:after multi-vterm
         (:map multi-vterm-mode-map
          :leader
          :n "mc" 'multi-vterm
          :n "mp" 'multi-vterm-prev
          :n "mn" 'multi-vterm-next)))
#+END_SRC

* tldr: an awesome cli reference: [[https://github.com/tldr-pages/tldr][github]]
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "package.el") "no")
(package! tldr)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package! tldr
  :commands (tldr)
  :config
  (setq tldr-directory-path (concat doom-etc-dir "tldr/")))
#+END_SRC

* Coding
** Bazel
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "package.el") "no")
(package! bazel)
#+END_SRC

** Python
*** auto-format
flake8+autoflake+yapf
#+BEGIN_SRC emacs-lisp
(set-formatter! 'yapf  "yapf " :modes '(python-mode))

(add-hook! 'before-save-hook
    (when (eq major-mode 'python-mode)
      (+format/buffer)))
#+END_SRC

*** debugger
#+BEGIN_SRC emacs-lisp
(defun python-toggle-breakpoint ()
  "Add an ipdb break point, highlight it."
  (interactive)
  (let ((trace (cond (t "breakpoint()")))
        (line (thing-at-point 'line)))
    (if (and line (string-match trace line))
        (kill-whole-line)
      (progn
        ;; (back-to-indentation)
        (insert trace)
        (insert "\n")
        (python-indent-line)))))
#+END_SRC

*** add extra syntax checker
#+BEGIN_SRC emacs-lisp
;; extra checkers after lsp
(defvar-local my/flycheck-local-cache nil)

(defun my/flycheck-checker-get (fn checker property)
  (or (alist-get property (alist-get checker my/flycheck-local-cache))
      (funcall fn checker property)))

(advice-add 'flycheck-checker-get :around 'my/flycheck-checker-get)

(add-hook 'lsp-managed-mode-hook
          (lambda ()
            (when (derived-mode-p 'python-mode)
              (setq my/flycheck-local-cache '((lsp . ((next-checkers . (python-pylint python-mypy python-flake8))))))
              (setq flycheck-pylintrc "~/.config/pylintrc"))))

#+END_SRC

*** ein
#+BEGIN_SRC emacs-lisp
(setq ein:output-area-inlined-images t)
(setq ein:use-auto-complete t)
(setq ein:use-smartrep t)
#+END_SRC

*** make repl popup nicer
#+BEGIN_SRC emacs-lisp
(set-popup-rule! "*Python*" :size 0.5 :side 'right :slot 1 :ttl nil :select nil :modeline nil :quit nil)
#+END_SRC

*** keybinds
#+begin_src emacs-lisp
(map!
 (:after python
  :map  python-mode-map
    :localleader
    "'"  #'+python/open-ipython-repl
    "a"  #'pyvenv-activate
    "D"  #'pyvenv-deactivate
    "sb" #'python-shell-send-buffer
    "sr" #'python-shell-send-region
    "SR" #'sh-send-line-or-region
    "db" #'python-toggle-breakpoint
    "if" #'python-fix-imports))
#+end_src

** C/C++
** Debugger Adapter (DAP)
*** keybinds
#+BEGIN_SRC emacs-lisp
(map!
 (:after dap-mode
   (:map dap-mode-map
    :leader
    "dd" 'dap-debug
    "de" 'dap-debug-edit-template
    "d." 'dap-hydra)))
#+END_SRC

** Copilot
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "package.el") "no")
(package! copilot
  :recipe (:host github :repo "zerolfx/copilot.el" :files ("*.el" "dist")))
#+END_SRC

#+begin_src emacs-lisp
;; accept completion from copilot and fallback to company
(use-package! copilot
  :hook (prog-mode . copilot-mode)
  :bind (:map copilot-completion-map
              ("C-e" . 'copilot-accept-completion)
              ("M-f" . 'copilot-accept-completion-by-word)
              ))
#+end_src

* Org-mode
** file location
#+begin_src emacs-lisp
(setq org-directory "~/Dropbox/notes/")
(setq org-roam-directory "~/Dropbox/notes/roam")

(defun filter-org-file (file)
  (equal (car (last (split-string file "\\."))) "org"))

(setq all-org-files
      (seq-filter 'filter-org-file (directory-files-recursively "~/Dropbox/notes/" ".*")))
#+end_src
** org-download
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "package.el") "no")
(package! org-download)
#+END_SRC

** roam-ui
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "package.el") "no")
(package! org-roam-ui)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package! websocket
    :after org-roam)

(use-package! org-roam-ui
    :after org-roam ;; or :after org
;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
;;         a hookable mode anymore, you're advised to pick something yourself
;;         if you don't care about startup time, use
;;  :hook (after-init . org-roam-ui-mode)
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))
#+END_SRC

** priorities
#+begin_src emacs-lisp
(setq org-default-priority ?C)
(setq org-lowest-priority ?D)
(setq org-highest-priority ?A)
#+end_src

** auto tangle
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "package.el") "no")
(package! org-auto-tangle)
#+END_SRC

#+begin_src emacs-lisp
(use-package org-auto-tangle
  :defer t
  :hook (org-mode . org-auto-tangle-mode))
#+end_src

** list appearances
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "package.el") "no")
(package! org-superstar)
#+END_SRC

#+begin_src emacs-lisp
(setq org-hide-emphasis-markers nil)
(setq org-superstar-headline-bullets-list '("‚Åñ"))
(setq org-ellipsis " ... ")
#+end_src

** keybind and some hooks
#+begin_src emacs-lisp
(add-hook! 'org-mode-hook
  (spacemacs/set-leader-keys-for-major-mode 'org-mode
    "I" 'org-clock-in
    "O" 'org-clock-out
    "R" 'org-refile)

  (org-superstar-mode)
  (setq org-agenda-files (directory-files-recursively "~/Dropbox/notes/" "\\.org$")))
#+end_src

** refile
#+BEGIN_SRC emacs-lisp
(setq org-refile-targets
      '((nil :maxlevel . 3)
        (org-agenda-files :maxlevel . 3)
        (all-org-files :maxlevel . 3)))
#+END_SRC

** agenda helpers
#+BEGIN_SRC emacs-lisp
(defun air-org-skip-subtree-if-habit ()
  "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
  (let ((subtree-end (save-excursion (org-end-of-subtree t))))
    (if (string= (org-entry-get nil "STYLE") "habit")
        subtree-end
      nil)))

(defun air-org-skip-subtree-if-priority (priority)
  "Skip an agenda subtree if it has a priority of PRIORITY.
     PRIORITY may be one of the characters ?A, ?B, or ?C."
  (let ((subtree-end (save-excursion (org-end-of-subtree t)))
        (pri-value (* 1000 (- org-lowest-priority priority)))
        (pri-current (org-get-priority (thing-at-point 'line t))))
    (if (= pri-value pri-current)
        subtree-end
      nil)))

(defun chanining/archive-when-done ()
  "Archive current entry if it is marked as DONE"
  (when (org-entry-is-done-p)
    (org-toggle-archive-tag)))
#+END_SRC

** agenda appearances
#+BEGIN_SRC emacs-lisp
(setq org-agenda-clockreport-parameter-plist
      (quote (:link t :maxlevel 3 :fileskip0 t :narrow 80 :formula %)))
(setq org-agenda-log-mode-items '(closed state clock))
(setq org-clock-idle-time 5)
(setq org-agenda-block-separator (string-to-char " "))
(setq org-agenda-breadcrumbs-separator " ü°í ")
;; (setq my-org-agenda-prefix-format " %-2i %(concat \"[\" (car (last(split-string (or (org-agenda-get-category) \"\") \"-\"))) \"]\") %b %t%s")
(setq my-org-agenda-prefix-format " %-2i %b %t%s")
#+END_SRC

** todo-keywords
#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
'((sequence "TODO(t)" "PROJ(p)" "LOOP(r)" "STRT(s)" "WAIT(w)" "HOLD(h)" "IDEA(i)" "|" "DONE(d)" "KILL(k)")
 (sequence "[ ](T)" "[-](S)" "[?](W)" "|" "[X](D)")
 (sequence "|" "OKAY(o)" "YES(y)" "NO(n)"))
)
#+END_SRC

** speed up agenda
#+BEGIN_SRC emacs-lisp
(setq org-agenda-inhibit-startup t)
(defadvice! fix-exclude-agenda-buffers-from-recentf-advice (orig-fn file)
  :override #'+org--exclude-agenda-buffers-from-recentf-a
  (let ((recentf-exclude (list (lambda (_file) t)))
        find-file-hook)
    (funcall orig-fn file)))
#+END_SRC

** daily/weekly agenda format
#+begin_src emacs-lisp
(setq org-agenda-custom-commands
      '(
        ("d" "Daily agenda and all TODOs"
         (
          (todo "STRT"
                ((org-agenda-prefix-format my-org-agenda-prefix-format)
                 (org-agenda-todo-keyword-format "")
                 (org-agenda-remove-tags t)
                 (org-agenda-overriding-header "\n\n‚ö° Currently Doing:\n‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫")))

          (todo "PROJ"
                ((org-agenda-prefix-format my-org-agenda-prefix-format)
                 (org-agenda-todo-keyword-format "")
                 (org-agenda-remove-tags t)
                 (org-agenda-overriding-header "üí´ Projects:\n‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫")))

          (todo "LOOP"
                ((org-agenda-prefix-format my-org-agenda-prefix-format)
                 (org-agenda-todo-keyword-format "")
                 (org-agenda-remove-tags t)
                 (org-agenda-overriding-header "üï≥ Learning:\n‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫")))

          (todo "IDEA"
                ((org-agenda-prefix-format my-org-agenda-prefix-format)
                 (org-agenda-todo-keyword-format "")
                 (org-agenda-remove-tags t)
                 (org-agenda-overriding-header "üí° Ideas to Explore:\n‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫")))

          ;; CLOCK REPROT
          (agenda "" (
                      (org-agenda-start-day "+0d")
                      (org-agenda-span 2)
                      (org-agenda-overriding-header " üóì Schedule:\n‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫")
                      ;; (org-agenda-repeating-timestamp-show-all nil)
                      (org-agenda-remove-tags t)
                      (org-agenda-prefix-format   "  %-2i %t %s  ")
                      ;; (org-agenda-prefix-format " %-2i %b %t%s")
                      ;; (org-agenda-todo-keyword-format " ‚òê ")
                      (org-agenda-current-time-string "‚Æú‚îà‚îà‚îà‚îà‚îà‚îà‚îà now")
                      (org-agenda-scheduled-leaders '("" ""))
                      (org-agenda-time-grid (quote ((daily today remove-match)
                                                    (0900 1200 1500 1800 2100)
                                                    "      " "‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà")))))

          (todo "TODO"
                ((org-agenda-prefix-format my-org-agenda-prefix-format)
                 (org-agenda-todo-keyword-format "")
                 (org-agenda-remove-tags t)
                 (org-agenda-overriding-header "üì• Inbox:\n‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫")))


          (todo "WAIT"
                ((org-agenda-skip-function '(or (air-org-skip-subtree-if-habit)
                                                (air-org-skip-subtree-if-priority ?A)
                                                (org-agenda-skip-if nil '(scheduled deadline))
                                                ))
                 (org-agenda-prefix-format my-org-agenda-prefix-format)
                 (org-agenda-todo-keyword-format "")
                 (org-agenda-remove-tags t)
                 (org-agenda-overriding-header "ü§î Do these next:\n‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫")))

          (todo "HOLD"
                ((org-agenda-skip-function '(or (air-org-skip-subtree-if-habit)
                                                (air-org-skip-subtree-if-priority ?A)
                                                (org-agenda-skip-if nil '(scheduled deadline))
                                                ))
                 (org-agenda-prefix-format my-org-agenda-prefix-format)
                 (org-agenda-todo-keyword-format "")
                 (org-agenda-remove-tags t)
                 (org-agenda-overriding-header "üìí Archive:\n‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫‚é∫")))

          )


         ((org-agenda-compact-blocks nil)
          (org-agenda-archives-mode t)
          (org-agenda-start-with-log-mode t)
          (org-agenda-start-with-clockreport-mode t)
          (org-agenda-start-on-weekday 1)))

        ("w" "Weekly review"
         agenda ""
         ((org-agenda-span 'week)
          (org-agenda-start-on-weekday 1)
          (org-agenda-start-with-log-mode t)
          (org-agenda-start-with-clockreport-mode t)
          (org-agenda-archives-mode t)
          (org-agenda-prefix-format " %-2i %t %s %b ")
          ))))
#+end_src

** journal
#+begin_src emacs-lisp
(setq org-journal-file-type 'monthly)
(setq org-journal-enable-agenda-integration t)
(setq org-capture-templates '(("j" "Journal entry" entry (function org-journal-find-location)
                               "* %(format-time-string org-journal-time-format)%^{Title}\n%i%?")))
#+end_src

** weekly time report review mode
#+begin_src emacs-lisp
(defun my-org-agenda-time-grid-spacing ()
  "Set different line spacing w.r.t. time duration."
  (save-excursion
    (let ((colors (list "IndianRed" "SeaGreen4" "sienna3" "DarkSlateGray4"))
          pos
          duration)
      (nconc colors colors)
      (goto-char (point-min))
      (while (setq pos (next-single-property-change (point) 'duration))
        (goto-char pos)
        (when (and (not (equal pos (point-at-eol)))
                   (setq duration (org-get-at-bol 'duration)))
          (let ((line-height (if (< duration 30) 1.0 (+ 0.5 (/ duration 60))))
                (ov (make-overlay (point-at-bol) (1+ (point-at-eol)))))
            (overlay-put ov 'face `(:background ,(car colors) :foreground "#FFFFFF"))
            (setq colors (cdr colors))
            (overlay-put ov 'line-height line-height)
            (overlay-put ov 'line-spacing (1- line-height))))))))
#+end_src

** agenda category icon list
#+begin_src emacs-lisp
(setq org-agenda-category-icon-alist
      `(
        (".*gtd.*" ,(list (all-the-icons-faicon "pencil")) nil nil :ascent center)
        (".*research.*" ,(list (all-the-icons-octicon "mortar-board")) nil nil :ascent center)
        (".*sail.*" ,(list (all-the-icons-octicon "briefcase")) nil nil :ascent center)
        (".*game_ai.*" ,(list (all-the-icons-octicon "briefcase")) nil nil :ascent center)
        (".*neuri.*" ,(list (all-the-icons-octicon "briefcase")) nil nil :ascent center)
        (".*career.*" ,(list (all-the-icons-octicon "briefcase")) nil nil :ascent center)
        (".*math.*" ,(list (all-the-icons-octicon "mortar-board")) nil nil :ascent center)
        (".*ai4sci.*" ,(list (all-the-icons-octicon "mortar-board")) nil nil :ascent center)
        (".*phd_application.*" ,(list (all-the-icons-octicon "mortar-board")) nil nil :ascent center)
        (".*reinforcement_learning.*" ,(list (all-the-icons-octicon "mortar-board")) nil nil :ascent center)
        (".*cvx.*" ,(list (all-the-icons-octicon "mortar-board")) nil nil :ascent center)
        (".*geometry.*" ,(list (all-the-icons-octicon "mortar-board")) nil nil :ascent center)
        (".*quantum.*" ,(list (all-the-icons-octicon "mortar-board")) nil nil :ascent center)
        (".*nus.*" ,(list (all-the-icons-octicon "mortar-board")) nil nil :ascent center)
        (".*MA.*" ,(list (all-the-icons-octicon "mortar-board")) nil nil :ascent center)
        (".*music.*" ,(list (all-the-icons-faicon "music")) nil nil :ascent center)
        (".*health.*" ,(list (all-the-icons-octicon "pulse")) nil nil :ascent center)
        (".*habit.*" ,(list (all-the-icons-octicon "pulse")) nil nil :ascent center)
        (".*workouts.*" ,(list (all-the-icons-octicon "pulse")) nil nil :ascent center)
        (".*nutrition.*" ,(list (all-the-icons-octicon "pulse")) nil nil :ascent center)
        (".*mindfulness.*" ,(list (all-the-icons-octicon "pulse")) nil nil :ascent center)
        ;; ("my_fin" ,(list (all-the-icons-faicon "usd")) nil nil :ascent center)
        (".*fin.*" ,(list (all-the-icons-faicon "line-chart" :height 0.68)) nil nil :ascent center)
        (".*ml.*" ,(list (all-the-icons-octicon "hubot")) nil nil :ascent center)
        (".*productivity.*" ,(list (all-the-icons-faicon "terminal")) nil nil :ascent center)
        (".*cs.*" ,(list (all-the-icons-faicon "terminal")) nil nil :ascent center)
        (".*cpp.*" ,(list (all-the-icons-faicon "terminal")) nil nil :ascent center)
        ;; (".*schedule.*" ,(list (all-the-icons-faicon "commenting")) nil nil :ascent center)
        (".*schedule.*" ,(list (all-the-icons-octicon "calendar")) nil nil :ascent center)
        (".*blockchain.*" ,(list (all-the-icons-faicon "lock")) nil nil :ascent center)
        ("vocab" ,(list (all-the-icons-faicon "book")) nil nil :ascent center)
        (".*read.*" ,(list (all-the-icons-faicon "book")) nil nil :ascent center)
        (".*cooking.*" ,(list (all-the-icons-faicon "fire")) nil nil :ascent center)
        (".*" ,(list (all-the-icons-faicon "check")) nil nil :ascent center)
        ))
#+end_src

** writeroom mode
#+begin_src emacs-lisp
(add-hook 'org-agenda-finalize-hook #'set-window-clean)

;; use percentage to calculate left/right margin instead of the default 80 char line width
(setq writeroom-width 0.8)

(defun set-window-clean ()
  "clean buffer for org agenda"
  (interactive)
  (setq mode-line-format nil)
  (writeroom-mode)
  (text-scale-decrease 2)
  (my-org-agenda-time-grid-spacing))
#+end_src

** auto export org beamer
#+begin_src emacs-lisp
(defun my-org-beamer-sync-hook ()
  (when (eq major-mode 'org-mode)
    (if (and (boundp 'org-latex-classes)
             (equal (car org-file-tags) #("presentation" 0 12 (inherited t))))
        (org-beamer-export-to-latex))))

(add-hook 'before-save-hook #'my-org-beamer-sync-hook)
#+end_src
** keybinds
#+BEGIN_SRC emacs-lisp
(map! :n "na" 'org-agenda)
#+END_SRC
* Research Workflow
So what is =research= anyway? It is the =compression= of information by human brain. There are two kinds of =compression=:
1. compression of inputs: people also call this =insight=.
2. compression of input / output pairs: people also call this =discovery=

** paths
I will use Dropbox as this provides integration with Overleaf.
#+BEGIN_SRC emacs-lisp
(defconst my-bib-libraries (list "~/Dropbox/Apps/Overleaf/lib.bib")) ; bib databases.
(defconst my-main-bib-library (nth 0 my-bib-libraries))              ; The main db is always the first
(defconst my-main-pdfs-library-paths `("~/Dropbox/bib/papers/inbox/" "~/Dropbox/bib/papers/read/" "~/Dropbox/bib/papers/cited/" "~/Dropbox/bib/textbooks/"))
(defconst my-main-pdfs-library-path (nth 0 my-main-pdfs-library-paths))
(defconst my-bib-notes-dir "~/Dropbox/notes/roam")
(setq bibtex-completion-bibliography my-bib-libraries
      bibtex-completion-library-path my-main-pdfs-library-paths
      bibtex-completion-notes-path my-bib-notes-dir
      bibtex-completion-pdf-open-function (lambda (fpath)
                                             (call-process "open" nil 0 nil fpath)))
(setq citar-library-paths my-main-pdfs-library-paths)
(setq citar-notes-paths my-main-pdfs-library-paths)
(setq citar-org-roam-subdir "research")
(setq org-noter-notes-search-path '("~/Dropbox/notes/roam/research"))
#+END_SRC

** information acquisition
*** TODO twitter
*** RSS: elfeed
**** RSS feeds
#+BEGIN_SRC emacs-lisp
(defun arxiv-rss-feed-url (cat &optional max-results sort-by sort-order)
  "Search for CAT"
  (unless max-results (setq max-results "100"))
  (unless sort-by (setq sort-by "submittedDate"))
  (unless sort-order (setq sort-order "descending"))
  (append
   (concat
   "http://export.arxiv.org/api/query?search_query=cat:" cat
   "&start=0&max_results=" max-results
   "&sortBy=" sort-by
   "&sortOrder=" sort-order)
   )
  )

(setq arxiv-feeds-funcs
      '(((arxiv-rss-feed-url "math.OC") math optimization control)
       ((arxiv-rss-feed-url "stat.ML") stats machine-learning )
       ((arxiv-rss-feed-url "cs.LG") cs machine-learning)
       ))

(setq arxiv-feeds
      (mapcar
       (lambda (x) (append (list (eval (car x))) (cdr x)))
       arxiv-feeds-funcs))

(setq acs-feeds  '(("https://feeds.feedburner.com/acs/jacsat" chemistry jacs)
                   ("https://feeds.feedburner.com/acs/jctcce" theory computation jctc)))
(setq elfeed-feeds (append arxiv-feeds acs-feeds))
#+END_SRC

**** feed scoring
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "package.el") "no")
(package! elfeed-score)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package elfeed-score
  :after elfeed
  :config
  (elfeed-score-load-score-file "~/dotfiles/elfeed/elfeed.score")
  (elfeed-score-enable)
  (define-key elfeed-search-mode-map "=" elfeed-score-map))
#+END_SRC

**** feed formatting
#+BEGIN_SRC emacs-lisp
(use-package! elfeed
  :config
  (add-hook! 'elfeed-search-mode-hook #'elfeed-update)

  (defun concatenate-authors (authors-list)
    "Given AUTHORS-LIST, list of plists; return string of all authors concatenated."
    (if (> (length authors-list) 1)
        (format "%s et al." (plist-get (nth 0 authors-list) :name))
      (plist-get (nth 0 authors-list) :name)))

  (defun my-search-print-fn (entry)
    "Print ENTRY to the buffer."
    (let* ((date (elfeed-search-format-date (elfeed-entry-date entry)))
           (title (or (elfeed-meta entry :title)
                      (elfeed-entry-title entry) ""))
           (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
           (entry-authors (concatenate-authors (elfeed-meta entry :authors)))
           (title-width (- (window-width) 10 elfeed-search-trailing-width))
           (title-column (elfeed-format-column title 100 :left))
           (entry-score (elfeed-format-column (number-to-string (elfeed-score-scoring-get-score-from-entry entry)) 10 :left))
           (authors-column (elfeed-format-column entry-authors 40 :left)))
      (insert (propertize date 'face 'elfeed-search-date-face) " ")
      (insert (propertize title-column 'face title-faces 'kbd-help title) " ")
      (insert (propertize authors-column 'kbd-help entry-authors) " ")
      (insert entry-score " ")
    ))

  (setq elfeed-search-print-entry-function #'my-search-print-fn)
  (setq elfeed-search-date-format '("%y-%m-%d" 10 :left))
  (setq elfeed-search-title-max-width 110)
  (setq elfeed-search-filter "@2-week-ago")
)
#+END_SRC

**** arxiv paper fetcher
#+BEGIN_SRC emacs-lisp
(defun my-elfeed-entry-to-arxiv ()
  "Fetch an arXiv paper into the local library from the current elfeed entry."
  (interactive)
  (let* ((link (elfeed-entry-link elfeed-show-entry))
         (match-idx (string-match "arxiv.org/abs/\\([0-9.]*\\)" link))
         (matched-arxiv-number (match-string 1 link)))
    (when matched-arxiv-number
      (message "Going to arXiv: %s" matched-arxiv-number)
      (arxiv-get-pdf-add-bibtex-entry matched-arxiv-number my-main-bib-library my-main-pdfs-library-path)
      )
    ))
#+END_SRC

*** offline PDF: biblio
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "package.el") "no")
(package! biblio)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq biblio-download-directory "~/Dropbox/Library/")
(setq citar-bib "~/Dropbox/Apps/Overleaf/lib.bib")

(defun biblio-current-buffer ()
  "Call an interactive function with the current buffer name."
  (interactive)
  (let ((query (buffer-name)))
    (biblio-lookup nil (string-remove-suffix ".pdf" query))))

(defun paste-to-citar-lib ()
  "Paste the current clipboard contents to a specific file."
  (interactive)
  ;; Ensure the kill ring is not empty
  (if (and kill-ring (not (string= "" (current-kill 0))))
      (let ((content (current-kill 0)))
        (with-temp-buffer
          (when (file-exists-p citar-bib)
            (insert-file-contents citar-bib))
          (goto-char (point-max))
          (insert content)
          (write-file citar-bib)))
    (message "Clipboard is empty.")))
#+END_SRC

*** web: zotra
workflow:
1. copy url in chrome (yy)
2. use XMonad to invoke `zotra-add-entry-and-pdf-from-url`
3. go through the options, in the end open the downloaded pdf
4. SPC C A to attach the pdf to the citar entry
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/dotfiles/doom/zotra")
(require 'zotra)
#+END_SRC

clean entry with org-ref after adding an entry
#+BEGIN_SRC emacs-lisp
(add-hook 'zotra-after-add-entry-hook 'org-ref-clean-bibtex-entry)
#+END_SRC

add entry then put the attachment in the right place
#+BEGIN_SRC emacs-lisp
(defun zotra-add-entry-and-pdf-from-url (url)
(interactive
   (list (read-string
          "url: "
          (ignore-errors (current-kill 0 t)))))
  (zotra-add-entry-from-url url citar-bib nil)
  (zotra-open-attachment-from-url url "/tmp")
  )
#+END_SRC

** information storage
*** org-ref
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "package.el") "no")
(package! org-ref)
#+END_SRC

*** citar
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "package.el") "no")
(package! citar)
(package! citar-embark)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package! citar
  ;; :hook (doom-after-init-modules . citar-refresh)
  :custom
  (citar-bibliography '("~/Dropbox/Apps/Overleaf/lib.bib"))
  :hook
  (LaTeX-mode . citar-capf-setup)
  (org-mode . citar-capf-setup)
  :config
  ;; This will add watches for the global bib files and in addition add a hook to LaTeX-mode-hook and org-mode-hook to add watches for local bibliographic files.
  ;; (citar-filenotify-setup '(LaTeX-mode-hook org-mode-hook))

  (require 'citar-org)
  (setq citar-file-extensions '("pdf" "org" "md")
        citar-file-open-function #'find-file)

  ;; by default citar store file as something like 2017.pdf, which is not really readable
  (defun my-citar-full-names (names)
    "Transform names like LastName, FirstName to FirstName LastName."
    (when (stringp names)
      (mapconcat
       (lambda (name)
         (if (eq 1 (length name))
             (split-string name " ")
           (let ((split-name (split-string name ", ")))
             (cl-concatenate 'string (nth 1 split-name) " " (nth 0 split-name)))))
       (split-string names " and ") ", ")))

  (setq citar-display-transform-functions
        '((("author" "editor") . my-citar-full-names)))

  (setq citar-templates
        '((main . "${author editor:55}     ${date year issued:4}     ${title:55}")
          (suffix . "  ${tags keywords keywords:40}")
          (preview . "${author editor} ${title}, ${journal publisher container-title collection-title booktitle} ${volume} (${year issued date}).\n")
          (note . "#+title: Notes on ${author editor}, ${title}")))

  ;; use consult-completing-read for enhanced interface
  (advice-add #'completing-read-multiple :override #'consult-completing-read-multiple))

(use-package citar-embark
  :after citar embark
  :no-require
  :config (citar-embark-mode))
#+END_SRC
*** for existing PDFs, add it to citar directly
#+BEGIN_SRC emacs-lisp
;;;###autoload
(defun citar-add-current-buffer-to-library (citekey)
  "Add a file to the library for CITEKEY.
The FILE can be added from an open buffer, a file path, or a
URL."
  (interactive (list (citar-select-ref)))
  (citar--check-configuration 'citar-library-paths)
  (unless citar-library-paths
    (user-error "Make sure `citar-library-paths' is non-nil"))
  (let* ((directory (if (cdr citar-library-paths)
                        (completing-read "Directory: " citar-library-paths)
                      (car citar-library-paths)))
         (filepath (expand-file-name citekey directory))
         (withext (lambda (extension)
                    (let* ((extension (or extension (read-string "File extension: "))))
                      (if (string-empty-p extension)
                          filepath
                        (concat filepath "." extension))))))
    (with-current-buffer (read-buffer "Add file buffer: " (current-buffer))
      (let ((destfile (funcall withext (and buffer-file-name (file-name-extension buffer-file-name)))))
        (write-file destfile 'confirm)))
    ))
#+END_SRC

*** create reading task from citar entry: org-roam-bibtex
workflow:
1. SPC C O: open an citar entry
2. M-o: embark
3. C: create reading task using the template below

#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "package.el") "no")
(package! org-roam-bibtex)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package! org-roam-bibtex
  :config
  (setq org-roam-capture-templates
        '(
          ("i" "inbox" entry
           "* TODO %?\n"
           :target (node "3b5d0d92-c6bb-4832-ae7a-cdc2e473ff58")
           :unnarrowed t
           :empty-lines-before 1
           :empty-lines-after 1
           :prepend t)
          ("r" "reading task" entry
           "* TODO [cite:@%^{citekey}]\n%?"
           :target (node "3b5d0d92-c6bb-4832-ae7a-cdc2e473ff58")
           :unnarrowed t
           :empty-lines-before 1
           :prepend t)))

  (require 'org-roam-bibtex)

  (setq citar-open-note-function 'orb-citar-edit-note
        orb-preformat-keywords '("citekey" "title" "url" "author-or-editor" "keywords" "file")
        orb-process-file-keyword t
        orb-file-field-extensions '("pdf"))
)

(add-hook! org-roam (org-roam-bibtex t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun org-roam-capture-inbox ()
    "Capture a TODO straight to the inbox."
    (interactive)
    (org-roam-capture- :goto nil
                       :keys "i"
                       :node (org-roam-node-from-id "3b5d0d92-c6bb-4832-ae7a-cdc2e473ff58")))

(defun org-roam-capture-bib ()
  "Capture using the reading task template."
  (interactive)
  (org-roam-capture- :goto nil
                     :keys "r"
                     :node (org-roam-node-from-id "3b5d0d92-c6bb-4832-ae7a-cdc2e473ff58")))

(map! (:after citar (:map citar-map "C" #'org-roam-capture-bib)))
#+END_SRC

** information processing
1. taking plain text note with org-roam-bibtex
2. taking note pinned to the associated PDF with org-noter
*** annotate pdf: org-noter + org-pdftools
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "package.el") "no")
(package! org-pdftools)
(package! org-noter-pdftools)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-noter
  :config
  (add-hook! 'org-noter-doc-mode-hook (evil-local-mode))
  (require 'org-noter-pdftools))

(use-package org-pdftools
  :hook (org-mode . org-pdftools-setup-link))
(use-package org-noter-pdftools
  :after org-noter
  :config
  ;; Add a function to ensure precise note is inserted
  (defun org-noter-pdftools-insert-precise-note (&optional toggle-no-questions)
    (interactive "P")
    (org-noter--with-valid-session
     (let ((org-noter-insert-note-no-questions (if toggle-no-questions
                                                   (not org-noter-insert-note-no-questions)
                                                 org-noter-insert-note-no-questions))
           (org-pdftools-use-isearch-link t)
           (org-pdftools-use-freepointer-annot t))
       (org-noter-insert-note (org-noter--get-precise-info)))))

  ;; fix https://github.com/weirdNox/org-noter/pull/93/commits/f8349ae7575e599f375de1be6be2d0d5de4e6cbf
  (defun org-noter-set-start-location (&optional arg)
    "When opening a session with this document, go to the current location.
With a prefix ARG, remove start location."
    (interactive "P")
    (org-noter--with-valid-session
     (let ((inhibit-read-only t)
           (ast (org-noter--parse-root))
           (location (org-noter--doc-approx-location (when (called-interactively-p 'any) 'interactive))))
       (with-current-buffer (org-noter--session-notes-buffer session)
         (org-with-wide-buffer
          (goto-char (org-element-property :begin ast))
          (if arg
              (org-entry-delete nil org-noter-property-note-location)
            (org-entry-put nil org-noter-property-note-location
                           (org-noter--pretty-print-location location))))))))
  (with-eval-after-load 'pdf-annot
    (add-hook 'pdf-annot-activate-handler-functions #'org-noter-pdftools-jump-to-note)))
#+END_SRC

*** writing notes: LaTeX
**** powerful snippet: laas
#+BEGIN_SRC emacs-lisp :tangle (if (fboundp 'my/tangle-conditionally) (my/tangle-conditionally "package.el") "no")
(package! laas
  :recipe (:host github :repo "tecosaur/LaTeX-auto-activating-snippets"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package laas
  :hook (LaTeX-mode . laas-mode)
  :config ; do whatever here
  (aas-set-snippets 'laas-mode
                    ;; set condition!
                    :cond #'texmathp ; expand only while in math
                    "supp" "\\supp"
                    "On" "O(n)"
                    "O1" "O(1)"
                    "Olog" "O(\\log n)"
                    "Olon" "O(n \\log n)"
                    ;; bind to functions!
                    "Sum" (lambda () (interactive)
                            (yas-expand-snippet "\\sum_{$1}^{$2} $0"))
                    "Span" (lambda () (interactive)
                             (yas-expand-snippet "\\Span($1)$0"))
                    ;; add accent snippets
                    :cond #'laas-object-on-left-condition
                    "qq" (lambda () (interactive) (laas-wrap-previous-object "sqrt"))))

(add-hook! 'tex-mode-hook (laas-mode t))
#+END_SRC

**** pdf should auto revert
#+BEGIN_SRC emacs-lisp
(add-hook 'pdf-view-mode-hook 'auto-revert-mode)
#+END_SRC
** keybinds
*** elfeed keybinds (SPC n)
#+BEGIN_SRC emacs-lisp
(map! (:after elfeed
       (:map elfeed-search-mode-map
        :desc "Open entry" "m" #'elfeed-search-show-entry)
       (:map elfeed-show-mode-map
        :desc "Fetch arXiv paper to the local library" "a" #'my-elfeed-entry-to-arxiv)))

(map! :leader
      :desc "arXiv paper to library" "n x" #'arxiv-get-pdf-add-bibtex-entry
      :desc "Elfeed" "n e" #'elfeed)
#+END_SRC


*** citar / org-roam(-bibtex) keybinds (SPC C)

create a reading task from a citar entry:
1. (SPC C O) to open the entry
2. (M-o) to embark, and select open-notes

#+BEGIN_SRC emacs-lisp
(map! (:after citar
(:leader
 :n "CC" #'org-roam-capture-inbox
 :n "CO" #'citar-open
 :n "CA" #'citar-add-current-buffer-to-library
 :n "CP" #'paste-to-citar-lib
                )
))
#+END_SRC

*** pdf keybinds (,)
#+BEGIN_SRC emacs-lisp
(map! (:after pdf-tools
              (:map pdf-view-mode-map
               :localleader
               "b" #'biblio-lookup
               "N" #'org-noter
               "S" #'org-noter-create-skeleton
               "q" #'org-noter-kill-session
                    )

              ;; custom evil like keymap
              (:map org-noter-doc-mode-map
               "j" #'org-noter-sync-next-note
               "k" #'org-noter-sync-prev-note
               "C-u" #'org-noter-sync-next-note
               "C-d" #'org-noter-sync-prev-note
               "zz" #'org-noter-sync-current-note
                    )
              ))

#+END_SRC

*** bib keybinds (,)
#+BEGIN_SRC emacs-lisp
(map! (:after bibtex
              (:map bibtex-mode-map
                    :localleader
                    "f" #'org-ref-clean-bibtex-entry
                    )
              ))
#+END_SRC

* Email
** mu4e
#+BEGIN_SRC emacs-lisp
(setq mu4e-update-interval 60)

(set-popup-rule! "*mu4e-main*" :size 0.95 :side 'bottom :vslot 1 :ttl nil :select nil :modeline nil :quit nil)
(set-popup-rule! "*mu4e-headers*" :size 0.95 :side 'bottom :vslot 1 :ttl nil :select nil :modeline nil :quit nil)
(set-popup-rule! "*mu4e-article*" :size 0.75 :side 'bottom :vslot 2 :ttl nil :select nil :modeline nil :quit nil)
#+END_SRC

** msmtp
#+BEGIN_SRC emacs-lisp
(after! mu4e
  (setq sendmail-program (executable-find "msmtp")
        send-mail-function #'smtpmail-send-it
        message-sendmail-f-is-evil t
        message-sendmail-extra-arguments '("--read-envelope-from")
        message-send-mail-function #'message-send-mail-with-sendmail))
#+END_SRC

** keybinds
#+BEGIN_SRC emacs-lisp
(map! :leader "EE" 'mu4e)
#+END_SRC

* Calendar
#+BEGIN_SRC emacs-lisp
(load! "secret")
(defun my-open-calendar ()
  (interactive)
  (cfw:open-calendar-buffer
   :contents-sources
   (list
    (cfw:org-create-source "steel blue")  ; orgmode source
    (cfw:ical-create-source "gcal" sail-gcal "sea green")
    (cfw:ical-create-source "gcal" my-gcal "IndianRed")))) ; google calendar ICS
#+END_SRC

* Other Keybinds
** cursor and window movements
#+begin_src emacs-lisp
(map!

 :v "s" #'evil-surround-region
 :o "S" #'evil-surround-edit
 :n "]e" #'move-text-line-down
 :n "[e" #'move-text-line-up

 :nv "M-n" #'evil-mc-make-and-goto-next-match
 :nv "M-p" #'evil-mc-make-and-goto-prev-match
 (:map evil-mc-cursor-map
  :nv "M-n" #'evil-mc-make-and-goto-next-match
  :nv "M-p" #'evil-mc-make-and-goto-prev-match
 )
 (:map evil-mc-key-map
  :nv "M-n" #'evil-mc-make-and-goto-next-match
  :nv "M-p" #'evil-mc-make-and-goto-prev-match
 )

 (:leader
  :n "RET" 'bookmark-jump

  ;; workspace / window management
  :n "o" 'spacemacs/workspaces-transient-state/body
  :n "0" 'treemacs-select-window
  :n "1" 'winum-select-window-1
  :n "2" 'winum-select-window-2
  :n "3" 'winum-select-window-3
  :n "4" 'winum-select-window-4
  :n "5" 'winum-select-window-5
  :n "6" 'winum-select-window-6
  :n "7" 'winum-select-window-7
  :n "8" 'winum-select-window-8
  :n "9" 'winum-select-window-9

  ;; jumps
  :n "ji" 'imenu
  :n "." 'evil-goto-definition
  :n "bb" 'switch-to-buffer)

)

;; Make evil-mode up/down operate in screen lines instead of logical lines
(define-key evil-motion-state-map "j" 'evil-next-visual-line)
(define-key evil-motion-state-map "k" 'evil-previous-visual-line)

;; Also in visual mode
(define-key evil-visual-state-map "j" 'evil-next-visual-line)
(define-key evil-visual-state-map "k" 'evil-previous-visual-line)
#+end_src

** searching
#+BEGIN_SRC emacs-lisp
(map!
 "C-s" 'consult-line
 "C-c C-s" '+vertico/search-symbol-at-point
 "C-c s" 'consult-ripgrep
)
#+END_SRC

** misc
#+BEGIN_SRC emacs-lisp
(map! (:leader
  :n "es" 'flycheck-list-errors
  :n "gs" 'magit-status
  :n "gff" 'magit-find-file
  :n "Ts" 'load-theme
))
#+END_SRC

** spacemacs leader
#+BEGIN_SRC emacs-lisp
(setq doom-localleader-key ",")
#+END_SRC

* Org agenda as starting page for emacs client
#+BEGIN_SRC emacs-lisp
(defun emacs-startup-screen ()
  "display the weekly org-agenda and all todos. used for client mode"
  (find-file "~/Dropbox/notes/roam/20221016141411-research.org")
  (setq org-agenda-sticky t)
  (org-agenda nil "d"))
#+END_SRC
